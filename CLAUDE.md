# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

js_dash is a Flutter application for drone/UAV communication and telemetry display using the MAVLink protocol. The app can communicate with ArduPilot, PX4, and other MAVLink-compatible autopilots to display real-time telemetry and send commands. The intent is to use with a custom autopilot and be a dash for the vehicle. The vehicle is a submersible jetski that is piloted so we want to create a cool looking dash. There will be multiple pages or views that the user can scroll between. One will be a map, one real-time data display and plotting, potentially a settings page. 

## Development Commands

### Flutter Commands
- `flutter run` - Run the app on connected device or emulator
- `flutter run -d web` - Run on web browser
- `flutter run -d linux` - Run on Linux desktop
- `flutter build` - Build release version
- `flutter test` - Run unit tests
- `flutter analyze` - Run static analysis and linting
- `flutter clean` - Clean build artifacts
- `flutter pub get` - Install dependencies
- `flutter pub upgrade` - Upgrade dependencies

### Testing
- `flutter test` - Run all tests
- `flutter test test/widget_test.dart` - Run specific test file

## Code Architecture

### Main Application Structure
- `lib/main.dart` - Entry point with Flutter application
- `lib/views/` - UI views (dashboard, telemetry, map, settings)
- `lib/services/` - Core services (connection, data management, settings)
- `lib/providers/` - Riverpod providers for state management
- `lib/models/` - Data models and configuration classes

### MAVLink Implementation (`lib/mavlink/`)

The MAVLink protocol is implemented using a **JSON metadata-driven architecture**. Message definitions are loaded at runtime from JSON files, not hardcoded.

#### Metadata Layer (`lib/mavlink/metadata/`)
- `mavlink_metadata.dart` - Data classes for message/field/enum metadata
- `metadata_registry.dart` - Registry that loads and queries metadata from JSON
  - O(1) lookups by message ID or name
  - Enum value resolution for display

#### Parser Layer (`lib/mavlink/parser/`)
- `mavlink_frame_parser.dart` - State machine parser for v1/v2 frames
- `message_decoder.dart` - Decodes payloads using field metadata
- `frame_builder.dart` - Builds outgoing v2 frames for testing/spoofing
- `mavlink_crc.dart` - X.25 CRC-16 implementation
- `mavlink_frame.dart` - Frame structure and protocol constants

#### Metadata Files
- `assets/mavlink_common.json` - Common dialect definitions (messages, enums, fields)
- Generated by `tools/mavlink_json_generator/generator.py` from MAVLink XML

#### C++ MAVLink Library (`interface/mavlink/`)
- **Purpose**: Standard C/C++ MAVLink implementation for embedded systems
- **Note**: Used for Arduino/embedded development, not Flutter app

### Communication Architecture
The app handles MAVLink communication through:
1. **Incoming**: IByteSource → MavlinkFrameParser → MavlinkMessageDecoder → MavlinkService → Application UI
2. **Outgoing**: MavlinkFrameBuilder → IByteSource (for spoof testing)

## Data Flow Architecture

### Complete Data Path

```
IByteSource (spoof/serial)
    │
    ▼ byteStream (raw bytes)
MavlinkFrameParser
    │
    ▼ stream (validated frames with CRC)
MavlinkMessageDecoder
    │
    ▼ decode() → MavlinkMessage (with named fields)
MavlinkService
    │
    ├──► GenericMessageTracker.trackMessage() [ALWAYS - pause independent]
    │         │
    │         ▼ statsStream (100ms interval updates)
    │    TimeSeriesDataManager
    │         │
    │         ▼ dataStream (CircularBuffers)
    │    UI Widgets (plots, gauges, telemetry display)
    │
    └──► messageStream [only when NOT paused]
         │
         ▼
    UI Widgets (raw message display)
```

### Key Design Decisions

1. **Single Tracking Point**: Messages are tracked ONLY in MavlinkService, not downstream services
2. **Pause Independence**: Tracking continues even when paused (for accurate frequency stats)
3. **100ms Stats Updates**: GenericMessageTracker emits stats every 100ms
4. **5-Second Frequency Window**: Frequency calculated from timestamps in last 5 seconds
5. **Circular Buffers**: TimeSeriesDataManager uses CircularBuffer for memory-bounded storage

### Data Rates

- **Spoof Source**: 10Hz fast telemetry (ATTITUDE, GLOBAL_POSITION_INT, VFR_HUD), 1Hz slow telemetry (SYS_STATUS), 1Hz heartbeat
- **Stats Updates**: 100ms interval
- **UI Updates**: Driven by dataStream emissions from TimeSeriesDataManager

### Provider Structure

The app uses Riverpod for dependency injection with this hierarchy:
- `mavlinkRegistryProvider` - Metadata for message decoding
- `mavlinkServiceProvider` - Central parsing and tracking
- `messageTrackerProvider` - Message statistics calculation
- `timeSeriesDataManagerProvider` - Time series storage in circular buffers
- `connectionManagerProvider` - Connection lifecycle management
- `connectionActionsProvider` / `dataActionsProvider` - UI action handlers

### Pause State Synchronization

When pause is triggered:
1. `TimeSeriesDataManager.pause()` sets `_isPaused = true`
2. It also calls `_connectionManager?.pause()` which pauses `MavlinkService`
3. `MavlinkService._isPaused` stops emitting to `messageStream`
4. However, `GenericMessageTracker.trackMessage()` continues (always tracks for frequency stats)
5. `TimeSeriesDataManager._processMessageUpdates()` checks `_isPaused` and skips buffer updates

### Key Services
- `MavlinkService` - Parses byte streams into decoded messages
- `GenericMessageTracker` - Tracks message statistics
- `TimeSeriesDataManager` - Stores time-series telemetry data
- `ConnectionManager` - Manages serial/spoof connections
- `SpoofByteSource` - Generates fake MAVLink data for testing

### Dependencies
- `flutter_riverpod` - State management
- `flutter_libserialport` - USB serial communication
- `fl_chart` - Telemetry plotting
- `latlong2` - GPS coordinate handling
- `json_annotation` - JSON serialization

## Platform Support
- **Web**: Supported via Chrome
- **Linux Desktop**: Supported
- **Android**: SDK not configured (requires Android Studio setup)
- **iOS/macOS**: Platform files present but not tested

## Development Notes

### MAVLink Metadata
- Message definitions are loaded from `assets/mavlink_common.json` at runtime
- To regenerate metadata from MAVLink XML: `python tools/mavlink_json_generator/generator.py`
- The JSON generator uses pymavlink to parse official MAVLink XML definitions
- Different dialects can be generated by changing the input XML file

### Testing
- Development must proceed with well-defined modules with tests
- All tests MUST pass before a module is complete
- Use `SpoofByteSource` for testing without real hardware
- The spoofer generates realistic MAVLink packets using the metadata registry

### Architecture Guidelines
- The target platform is Linux desktop
- Communication is via USB-serial in production
- Use `SpoofConnectionConfig` for testing without autopilot hardware
- Ensure code is modular with proper separation of concerns
- All MAVLink parsing uses the metadata registry - never hardcode message definitions